## 一文掌握并查集算法

### 定义

> 并查集，在一些有N个元素的[集合](https://baike.baidu.com/item/集合/2908117)应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的[时间复杂度](https://baike.baidu.com/item/时间复杂度/1894057)也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。
>
> 并查集是一种树型的数据结构，用于处理一些不相交[集合](https://baike.baidu.com/item/集合/2908117)（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。



### 伪代码

```python
class UnionFindSet:
	def UnionFindSet(n):
		parents = [0,1...n] # 记录每个元素的parent即根节点
		ranks =[0,0...0]    # 记录节点的rank值
	
    # 如下图 递归版本 路径压缩(Path Compression)
    # 如果当前的x不是其父节点，就找到当前x的父节点的根节点(find(parents[x])) 并将这个值赋值给x的父节点
	def find(x):
		if ( x !=parents[x]): # 注意这里的if
			parents[x] = find(parents[x])
		return parents[x]

	# 如下图 根据Rank来合并(Union by Rank)
	def union(x,y):
		rootX = find(x) # 找到x的根节点rootX
		rootY = find(y) # 找到y的根节点rootY
        #取rank值小的那个挂到大的那个节点下面，此时两个根节点的rank值并没有发生变化，还是原来的值
		if(ranks[rootX]>ranks[rootY]): parents[rootY] = rootX 
		if(ranks[rootX]<ranks[rootY]): parents[rootX] = rootY
        # 当两个rank值相等时，随便选择一个根节点挂到另外一个跟节点上，但是被挂的那个根节点的rank值需要+1    
		if(ranks[rootX] == ranks[rootY] ):
			parents[rootY] = rootX
			ranks[rootY]++
```



> 非递归版本find(x)，如下图

```python
	def find(x):
		rootX = x # 找到x的根节点
		while (rootX!=parents[rootX]):
			rootX = parents[rootX]
		curr = x # 准备一个curr变量
		while (curr!=rootX):
			next = parents[curr] # 暂存curr的父节点
			parents[curr] = rootX # 将curr节点的父节点设置为rootX
			curr = next # curr节点调到下个节点
```

![image-20200812094204053](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\classical_algorithm\一文掌握并查集.assets\image-20200812094204053.png)



#### 根据Rank来合并($Union$ $by$ $Rank$)

![image-20200812090131209](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\classical_algorithm\一文掌握并查集.assets\image-20200812090131209.png)

#### 路径压缩($Path$ $Compression$)

![image-20200812090146844](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\classical_algorithm\一文掌握并查集.assets\image-20200812090146844.png)





### 应用

![image-20200812134649394](D:\Dev\SrcCode\geek-algorithm-leetcode\src\main\leetcode_manuscripts\classical_algorithm\一文掌握并查集算法.assets\image-20200812134649394.png)

并查集

```java
        static class UnionFindSet {
            int[] parents;
            int[] ranks;

            public UnionFindSet(int n) {
                parents = new int[n];
                ranks = new int[n];
                for (int i = 0; i < n; i++) {
                    parents[i] = i;
                }
            }


            public int find(int x) {
                if (x != parents[x]) {
                    parents[x] = find(parents[x]);
                }
                System.out.println(x + ":" + parents[x]);
                return parents[x];
            }

            public void union(int x, int y) {
                int rootX = find(x);
                int rootY = find(y);
                if (rootX == rootY) return;
                if (ranks[rootX] > ranks[rootY]) parents[rootY] = rootX;
                if (ranks[rootX] < ranks[rootY]) parents[rootX] = rootY;
                if (ranks[rootX] == ranks[rootY]) {
                    parents[rootY] = rootX;
                    ranks[rootY]++;
                }
            }
        }

```



#### 主体代码

```java
int m, n;
int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

public void solve(char[][] board) {
    if (board == null || board.length == 0) return;
    m = board.length;
    n = board[0].length;
    int initValue = m * n + 1;
    UnionFindSet unionFindSet = new UnionFindSet(initValue);
    int dummy = m * n;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (board[i][j] == 'O') {
                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {
                    unionFindSet.union(node(i, j), dummy);
                } else {
                    for (int k = 0; k < directions.length; k++) {
                        int nextI = i + directions[k][0];
                        int nextJ = j + directions[k][1];
                        if ((nextI > 0 || nextI < m || nextJ > 0 || nextJ < n) && board[nextI][nextJ] == 'O') {
                            unionFindSet.union(node(i, j), node(nextI, nextJ));
                        }
                    }
                }
            }
        }
    }
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (unionFindSet.find(node(i, j)) == unionFindSet.find(dummy)) {
                board[i][j] = 'O';
            } else {
                board[i][j] = 'X';
            }
        }
    }
}

public int node(int i, int j) {
    return i * n + j;
}
```





### Reference

- https://blog.csdn.net/jc514984625/article/details/52049000?utm_source=blogxgwz6
- 视频资料

