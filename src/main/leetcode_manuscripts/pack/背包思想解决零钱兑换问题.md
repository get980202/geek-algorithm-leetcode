#### 背包思想解决零钱兑换问题

##### 322.零钱兑换

![JEty1e.png](https://s1.ax1x.com/2020/04/17/JEty1e.png)





##### 518.零钱兑换II

![GIA2J1.png](https://s1.ax1x.com/2020/04/09/GIA2J1.png)

##### 题目分析

- **假设每一种面额的硬币有无限个** 这是题目描述的，符合**完全背包问题**:每件物品可以无限制的取用，只要不超过总的背包容量，把背包撑爆

---

##### 完全背包问题的抽象模型

> 动态规划的几大要素：状态，选择以及边界条件

##### 参数定义：

- $N$件物品
- $V$背包的总容量
- $Ci$放入第$i$件物品耗费的费用
- $Wi$放入第$i$件物品得到的价值动态规划的几大要素：状态，选择以及边界条件

每件物品可以 取用0件，1件，2件...$V/Ci$件，

##### **定义状态**

- $F[i,v]$表示前$i$个物品恰好放入容量为$v$的背包时获取到的最大价值，很容易得到如下的动态转移方程：
  - $F[i,v]=max(F[i-1,v-kCi]+kWi|kCi∈[0,v])$

##### 边界条件

- 如果创建一个$dp=int[N+1][V+1]$的二维动态数组，当$dp[0][0]$时，表示的时物品数与背包的容量都是$0$的，显然其结果为$0$

---



##### 方法1:朴素版(三层循环)

##### 定义状态

- $dp[i][j]$: $coins[0..i]$范围内的硬币，组成目标金额为$j$，能得到的组合数
- 当遇到一种新的硬币$coins[i]$时，可以选$0$种，$1$种，$2$种，直到$k$种，因为可以对于一种硬币进行无数种选择，只要$j-coins[i-1]≥0$即可，不满足这个条件，背包撑爆，对于这个状态本身没有什么意义，将上面的每个子状态的和累加，即是所求$dp[i][j]$
  - 动态转移方程：$ \sum_{0}^k dp[i-1][j-k*coins[i-1]] $

##### 边界条件

- 多设置一行，$dp=int[n+1][...]$  将$dp[0][0]$置为$1$，其他为$0$

```java
    public int change1st(int amount, int[] coins) {
        int n = coins.length;
        int[][] dp = new int[n + 1][amount + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= amount; j++) {
                for (int k = 0; k * coins[i - 1] <= j; k++) {
                    dp[i][j] += dp[i - 1][j - k * coins[i - 1]];
                }
            }
        }
        return dp[n][amount];
    }
```

##### 复杂度分析

- 时间复杂度：$O(N*amount^2)$其中$N$是硬币的个数即$coins$数组的长度，$amount$是金额
- 空间复杂度：$O(N*amount)$,即$dp$使用的空间

#####  方法2：优化(两层循环)

##### 定义状态

- $dp[i][j]$：$coins[0....i-1]$这前$i$个硬币，组成金额为$j$，能得到的组合数
- $dp[i][j]$依赖于两个状态，选不选$coins[i-1]$这个硬币，
  - 不选的时候为$dp[i-1][j]$,不选$coins[i-1]$时，只能在前$i-1$个硬币中组成$j$
  - 选的时候为$dp[i][j-coins[i-1]]$，选$coins[i-1]$时，总的金额减少到$j-coins[i-1]$,但由于是完全背包问题，每个物品可以选无限次，所以，剩下的可以选的硬币还是应该是$coins[0...i-1]$前$i$个
  - 状态转移方程：$dp[i][j]$=$dp[i-1][j]$+$dp[i][j-coins[i-1]]$，这其中可以做个优化，$j-coins[i-1]<0$的情况无意义，可以过滤

##### 边界条件

- $dp[i][0]$前$i$个硬币形成金额为$0$的组合数，为$1$那就是不选任何硬币，只有这$1$种选法
- $dp[0][j]$其中$j≠0$，前$0$种硬币组成目标金额为$j$的组合数，初始化时，$dp==int[n+1][...]$前$0$种硬币其实是没有硬币的，翻译下来是没有硬币，如何组成$j$，答案显然是$0$
- 注意在初始化$dp[0][j]$时，不要将$dp[0][0]$的状态覆盖掉了

##### 结果

- $dp[n][amount]$前$n$中硬币形成了$amount$的组合数，即$coins[0...n-1]$形成了$amount$

```java
    public int change2nd(int amount, int[] coins) {
    	int n = coins.length;
        int[][] dp = new int[n + 1][amount + 1];
        for (int i = 0; i <= n; i++) dp[i][0] = 1;
        for (int j = 1; j <= amount; j++) dp[0][j] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= amount; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j - coins[i - 1] >= 0) dp[i][j] += dp[i][j - coins[i - 1]];
            }
        }
        return dp[n][amount];
    }
```

##### 复杂度分析

- 时间复杂度：$O(N*amount)$其中$N$是硬币的个数即$coins$数组的长度，$amount$是金额
- 空间复杂度：$O(N*amount)$,即$dp$使用的空间

- 相比于**方法1**,优化了一层循环，时间复杂度变好

##### 方法3：优化(一维数组)

##### 定义状态

- 将方法2中的$dp[i][j] =dp[i - 1][j]+ dp[i][j - coins[i - 1]];$去掉一维$i$得到，$dp[j]=dp[j+dp[j-coins[i]]]$这里$i$从$0$开始的，不需要取$coins[i-1]$

##### 边界条件

- 没有硬币时候，不选任何硬币，可以组成金额为$0$，只有这么一种组合，$dp[0]$等价于$dp[0][0]$

```java
 public int change3rd(int amount, int[] coins) {
        int n = coins.length;
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int i = 0; i < n; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] = dp[j] + dp[j - coins[i]];
            }
        }
        return dp
```

##### 复杂度分析

- 时间复杂度：$O(N*amount)$其中$N$是硬币的个数即$coins$数组的长度，$amount$是金额
- 空间复杂度：$O(amount)$,即$dp$使用的空间，将二维降低为一维



































